{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -Wno-missing-export-lists #-}
{-# OPTIONS_GHC -Wno-missing-import-lists #-}

module OpenTelemetry.Instrumentation.Hedis.Internal.Action where

import OpenTelemetry.Instrumentation.Hedis.Internal.Wrapper
import qualified Database.Redis as Orig
import Database.Redis hiding (append, auth, bgrewriteaof, bgsave, bitcount, bitcountRange, bitopAnd, bitopNot, bitopOr, bitopXor, bitpos, blpop, brpop, brpoplpush, clientGetname, clientList, clientPause, clientReply, clientSetname, clusterGetKeysInSlot, clusterNodes, clusterSetSlotImporting, clusterSetSlotMigrating, clusterSetSlotNode, clusterSetSlotStable, clusterSlots, commandCount, commandInfo, configGet, configResetstat, configRewrite, configSet, dbsize, debugObject, decr, decrby, del, dump, echo, eval, evalsha, exists, expire, expireat, flushall, flushdb, get, getType, getbit, getrange, getset, hdel, hexists, hget, hgetall, hincrby, hincrbyfloat, hkeys, hlen, hmget, hmset, hscan, hscanOpts, hset, hsetnx, hstrlen, hvals, incr, incrby, incrbyfloat, info, infoSection, keys, lastsave, lindex, linsertAfter, linsertBefore, llen, lpop, lpush, lpushx, lrange, lrem, lset, ltrim, mget, migrate, migrateMultiple, move, mset, msetnx, objectEncoding, objectIdletime, objectRefcount, persist, pexpire, pexpireat, pfadd, pfcount, pfmerge, ping, psetex, pttl, publish, quit, randomkey, rename, renamenx, restore, restoreReplace, rpop, rpoplpush, rpush, rpushx, sadd, save, scan, scanOpts, scard, scriptDebug, scriptExists, scriptFlush, scriptKill, scriptLoad, sdiff, sdiffstore, select, sendRequest, set, setOpts, setbit, setex, setnx, setrange, sinter, sinterstore, sismember, slaveof, slowlogGet, slowlogLen, slowlogReset, smembers, smove, sort, sortStore, spop, spopN, srandmember, srandmemberN, srem, sscan, sscanOpts, strlen, sunion, sunionstore, time, ttl, wait, xack, xadd, xaddOpts, xclaim, xclaimJustIds, xdel, xgroupCreate, xgroupDelConsumer, xgroupDestroy, xgroupSetId, xinfoConsumers, xinfoGroups, xinfoStream, xlen, xpendingDetail, xpendingSummary, xrange, xread, xreadGroup, xreadGroupOpts, xreadOpts, xrevRange, xtrim, zadd, zaddOpts, zcard, zcount, zincrby, zinterstore, zinterstoreWeights, zlexcount, zrange, zrangeWithscores, zrangebylex, zrangebylexLimit, zrangebyscore, zrangebyscoreLimit, zrangebyscoreWithscores, zrangebyscoreWithscoresLimit, zrank, zrem, zremrangebylex, zremrangebyrank, zremrangebyscore, zrevrange, zrevrangeWithscores, zrevrangebyscore, zrevrangebyscoreLimit, zrevrangebyscoreWithscores, zrevrangebyscoreWithscoresLimit, zrevrank, zscan, zscanOpts, zscore, zunionstore, zunionstoreWeights)

import Control.Monad.IO.Unlift (MonadUnliftIO)
import Data.ByteString (ByteString)
import GHC.Stack (HasCallStack)
import qualified OpenTelemetry.Trace.Monad as Otel (MonadTracer)

append :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> m (f Integer)
append = wrap2 "append" Orig.append
auth :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f Status)
auth = wrap1 "auth" Orig.auth
bgrewriteaof :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => m (f Status)
bgrewriteaof = wrap0 "bgrewriteaof" Orig.bgrewriteaof
bgsave :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => m (f Status)
bgsave = wrap0 "bgsave" Orig.bgsave
bitcount :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f Integer)
bitcount = wrap1 "bitcount" Orig.bitcount
bitcountRange :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Integer -> Integer -> m (f Integer)
bitcountRange = wrap3 "bitcountRange" Orig.bitcountRange
bitopAnd :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> [ByteString] -> m (f Integer)
bitopAnd = wrap2 "bitopAnd" Orig.bitopAnd
bitopNot :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> m (f Integer)
bitopNot = wrap2 "bitopNot" Orig.bitopNot
bitopOr :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> [ByteString] -> m (f Integer)
bitopOr = wrap2 "bitopOr" Orig.bitopOr
bitopXor :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> [ByteString] -> m (f Integer)
bitopXor = wrap2 "bitopXor" Orig.bitopXor
bitpos :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Integer -> Integer -> Integer -> m (f Integer)
bitpos = wrap4 "bitpos" Orig.bitpos
blpop :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => [ByteString] -> Integer -> m (f (Maybe (ByteString, ByteString)))
blpop = wrap2 "blpop" Orig.blpop
brpop :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => [ByteString] -> Integer -> m (f (Maybe (ByteString, ByteString)))
brpop = wrap2 "brpop" Orig.brpop
brpoplpush :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> Integer -> m (f (Maybe ByteString))
brpoplpush = wrap3 "brpoplpush" Orig.brpoplpush
clientGetname :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => m (f Status)
clientGetname = wrap0 "clientGetname" Orig.clientGetname
clientList :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => m (f [ByteString])
clientList = wrap0 "clientList" Orig.clientList
clientPause :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => Integer -> m (f Status)
clientPause = wrap1 "clientPause" Orig.clientPause
clientReply :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ReplyMode -> m (f Bool)
clientReply = wrap1 "clientReply" Orig.clientReply
clientSetname :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f ByteString)
clientSetname = wrap1 "clientSetname" Orig.clientSetname
clusterGetKeysInSlot :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => Integer -> Integer -> m (f [ByteString])
clusterGetKeysInSlot = wrap2 "clusterGetKeysInSlot" Orig.clusterGetKeysInSlot
clusterNodes :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => m (f ClusterNodesResponse)
clusterNodes = wrap0 "clusterNodes" Orig.clusterNodes
clusterSetSlotImporting :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => Integer -> ByteString -> m (f Status)
clusterSetSlotImporting = wrap2 "clusterSetSlotImporting" Orig.clusterSetSlotImporting
clusterSetSlotMigrating :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => Integer -> ByteString -> m (f Status)
clusterSetSlotMigrating = wrap2 "clusterSetSlotMigrating" Orig.clusterSetSlotMigrating
clusterSetSlotNode :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => Integer -> ByteString -> m (f Status)
clusterSetSlotNode = wrap2 "clusterSetSlotNode" Orig.clusterSetSlotNode
clusterSetSlotStable :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => Integer -> m (f Status)
clusterSetSlotStable = wrap1 "clusterSetSlotStable" Orig.clusterSetSlotStable
clusterSlots :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => m (f ClusterSlotsResponse)
clusterSlots = wrap0 "clusterSlots" Orig.clusterSlots
commandCount :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => m (f Integer)
commandCount = wrap0 "commandCount" Orig.commandCount
commandInfo :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => [ByteString] -> m (f [ByteString])
commandInfo = wrap1 "commandInfo" Orig.commandInfo
configGet :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f [(ByteString, ByteString)])
configGet = wrap1 "configGet" Orig.configGet
configResetstat :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => m (f Status)
configResetstat = wrap0 "configResetstat" Orig.configResetstat
configRewrite :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => m (f Status)
configRewrite = wrap0 "configRewrite" Orig.configRewrite
configSet :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> m (f Status)
configSet = wrap2 "configSet" Orig.configSet
dbsize :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => m (f Integer)
dbsize = wrap0 "dbsize" Orig.dbsize
debugObject :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f ByteString)
debugObject = wrap1 "debugObject" Orig.debugObject
decr :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f Integer)
decr = wrap1 "decr" Orig.decr
decrby :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Integer -> m (f Integer)
decrby = wrap2 "decrby" Orig.decrby
del :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => [ByteString] -> m (f Integer)
del = wrap1 "del" Orig.del
dump :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f ByteString)
dump = wrap1 "dump" Orig.dump
echo :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f ByteString)
echo = wrap1 "echo" Orig.echo
eval :: ((RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack), RedisResult a) => ByteString -> [ByteString] -> [ByteString] -> m (f a)
eval = wrap3 "eval" Orig.eval
evalsha :: ((RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack), RedisResult a) => ByteString -> [ByteString] -> [ByteString] -> m (f a)
evalsha = wrap3 "evalsha" Orig.evalsha
exists :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f Bool)
exists = wrap1 "exists" Orig.exists
expire :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Integer -> m (f Bool)
expire = wrap2 "expire" Orig.expire
expireat :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Integer -> m (f Bool)
expireat = wrap2 "expireat" Orig.expireat
flushall :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => m (f Status)
flushall = wrap0 "flushall" Orig.flushall
flushdb :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => m (f Status)
flushdb = wrap0 "flushdb" Orig.flushdb
get :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f (Maybe ByteString))
get = wrap1 "get" Orig.get
getType :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f RedisType)
getType = wrap1 "getType" Orig.getType
getbit :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Integer -> m (f Integer)
getbit = wrap2 "getbit" Orig.getbit
getrange :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Integer -> Integer -> m (f ByteString)
getrange = wrap3 "getrange" Orig.getrange
getset :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> m (f (Maybe ByteString))
getset = wrap2 "getset" Orig.getset
hdel :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> [ByteString] -> m (f Integer)
hdel = wrap2 "hdel" Orig.hdel
hexists :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> m (f Bool)
hexists = wrap2 "hexists" Orig.hexists
hget :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> m (f (Maybe ByteString))
hget = wrap2 "hget" Orig.hget
hgetall :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f [(ByteString, ByteString)])
hgetall = wrap1 "hgetall" Orig.hgetall
hincrby :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> Integer -> m (f Integer)
hincrby = wrap3 "hincrby" Orig.hincrby
hincrbyfloat :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> Double -> m (f Double)
hincrbyfloat = wrap3 "hincrbyfloat" Orig.hincrbyfloat
hkeys :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f [ByteString])
hkeys = wrap1 "hkeys" Orig.hkeys
hlen :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f Integer)
hlen = wrap1 "hlen" Orig.hlen
hmget :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> [ByteString] -> m (f [Maybe ByteString])
hmget = wrap2 "hmget" Orig.hmget
hmset :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> [(ByteString, ByteString)] -> m (f Status)
hmset = wrap2 "hmset" Orig.hmset
hscan :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Cursor -> m (f (Cursor, [(ByteString, ByteString)]))
hscan = wrap2 "hscan" Orig.hscan
hscanOpts :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Cursor -> ScanOpts -> m (f (Cursor, [(ByteString, ByteString)]))
hscanOpts = wrap3 "hscanOpts" Orig.hscanOpts
hset :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> ByteString -> m (f Integer)
hset = wrap3 "hset" Orig.hset
hsetnx :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> ByteString -> m (f Bool)
hsetnx = wrap3 "hsetnx" Orig.hsetnx
hstrlen :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> m (f Integer)
hstrlen = wrap2 "hstrlen" Orig.hstrlen
hvals :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f [ByteString])
hvals = wrap1 "hvals" Orig.hvals
incr :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f Integer)
incr = wrap1 "incr" Orig.incr
incrby :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Integer -> m (f Integer)
incrby = wrap2 "incrby" Orig.incrby
incrbyfloat :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Double -> m (f Double)
incrbyfloat = wrap2 "incrbyfloat" Orig.incrbyfloat
info :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => m (f ByteString)
info = wrap0 "info" Orig.info
infoSection :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f ByteString)
infoSection = wrap1 "infoSection" Orig.infoSection
keys :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f [ByteString])
keys = wrap1 "keys" Orig.keys
lastsave :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => m (f Integer)
lastsave = wrap0 "lastsave" Orig.lastsave
lindex :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Integer -> m (f (Maybe ByteString))
lindex = wrap2 "lindex" Orig.lindex
linsertAfter :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> ByteString -> m (f Integer)
linsertAfter = wrap3 "linsertAfter" Orig.linsertAfter
linsertBefore :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> ByteString -> m (f Integer)
linsertBefore = wrap3 "linsertBefore" Orig.linsertBefore
llen :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f Integer)
llen = wrap1 "llen" Orig.llen
lpop :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f (Maybe ByteString))
lpop = wrap1 "lpop" Orig.lpop
lpush :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> [ByteString] -> m (f Integer)
lpush = wrap2 "lpush" Orig.lpush
lpushx :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> m (f Integer)
lpushx = wrap2 "lpushx" Orig.lpushx
lrange :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Integer -> Integer -> m (f [ByteString])
lrange = wrap3 "lrange" Orig.lrange
lrem :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Integer -> ByteString -> m (f Integer)
lrem = wrap3 "lrem" Orig.lrem
lset :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Integer -> ByteString -> m (f Status)
lset = wrap3 "lset" Orig.lset
ltrim :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Integer -> Integer -> m (f Status)
ltrim = wrap3 "ltrim" Orig.ltrim
mget :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => [ByteString] -> m (f [Maybe ByteString])
mget = wrap1 "mget" Orig.mget
migrate :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> ByteString -> Integer -> Integer -> m (f Status)
migrate = wrap5 "migrate" Orig.migrate
migrateMultiple :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> Integer -> Integer -> MigrateOpts -> [ByteString] -> m (f Status)
migrateMultiple = wrap6 "migrateMultiple" Orig.migrateMultiple
move :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Integer -> m (f Bool)
move = wrap2 "move" Orig.move
mset :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => [(ByteString, ByteString)] -> m (f Status)
mset = wrap1 "mset" Orig.mset
msetnx :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => [(ByteString, ByteString)] -> m (f Bool)
msetnx = wrap1 "msetnx" Orig.msetnx
objectEncoding :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f ByteString)
objectEncoding = wrap1 "objectEncoding" Orig.objectEncoding
objectIdletime :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f Integer)
objectIdletime = wrap1 "objectIdletime" Orig.objectIdletime
objectRefcount :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f Integer)
objectRefcount = wrap1 "objectRefcount" Orig.objectRefcount
persist :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f Bool)
persist = wrap1 "persist" Orig.persist
pexpire :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Integer -> m (f Bool)
pexpire = wrap2 "pexpire" Orig.pexpire
pexpireat :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Integer -> m (f Bool)
pexpireat = wrap2 "pexpireat" Orig.pexpireat
pfadd :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> [ByteString] -> m (f Integer)
pfadd = wrap2 "pfadd" Orig.pfadd
pfcount :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => [ByteString] -> m (f Integer)
pfcount = wrap1 "pfcount" Orig.pfcount
pfmerge :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> [ByteString] -> m (f ByteString)
pfmerge = wrap2 "pfmerge" Orig.pfmerge
ping :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => m (f Status)
ping = wrap0 "ping" Orig.ping
psetex :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Integer -> ByteString -> m (f Status)
psetex = wrap3 "psetex" Orig.psetex
pttl :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f Integer)
pttl = wrap1 "pttl" Orig.pttl
publish :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> m (f Integer)
publish = wrap2 "publish" Orig.publish
quit :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => m (f Status)
quit = wrap0 "quit" Orig.quit
randomkey :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => m (f (Maybe ByteString))
randomkey = wrap0 "randomkey" Orig.randomkey
rename :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> m (f Status)
rename = wrap2 "rename" Orig.rename
renamenx :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> m (f Bool)
renamenx = wrap2 "renamenx" Orig.renamenx
restore :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Integer -> ByteString -> m (f Status)
restore = wrap3 "restore" Orig.restore
restoreReplace :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Integer -> ByteString -> m (f Status)
restoreReplace = wrap3 "restoreReplace" Orig.restoreReplace
rpop :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f (Maybe ByteString))
rpop = wrap1 "rpop" Orig.rpop
rpoplpush :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> m (f (Maybe ByteString))
rpoplpush = wrap2 "rpoplpush" Orig.rpoplpush
rpush :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> [ByteString] -> m (f Integer)
rpush = wrap2 "rpush" Orig.rpush
rpushx :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> m (f Integer)
rpushx = wrap2 "rpushx" Orig.rpushx
sadd :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> [ByteString] -> m (f Integer)
sadd = wrap2 "sadd" Orig.sadd
save :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => m (f Status)
save = wrap0 "save" Orig.save
scan :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => Cursor -> m (f (Cursor, [ByteString]))
scan = wrap1 "scan" Orig.scan
scanOpts :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => Cursor -> ScanOpts -> m (f (Cursor, [ByteString]))
scanOpts = wrap2 "scanOpts" Orig.scanOpts
scard :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f Integer)
scard = wrap1 "scard" Orig.scard
scriptDebug :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => DebugMode -> m (f Bool)
scriptDebug = wrap1 "scriptDebug" Orig.scriptDebug
scriptExists :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => [ByteString] -> m (f [Bool])
scriptExists = wrap1 "scriptExists" Orig.scriptExists
scriptFlush :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => m (f Status)
scriptFlush = wrap0 "scriptFlush" Orig.scriptFlush
scriptKill :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => m (f Status)
scriptKill = wrap0 "scriptKill" Orig.scriptKill
scriptLoad :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f ByteString)
scriptLoad = wrap1 "scriptLoad" Orig.scriptLoad
sdiff :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => [ByteString] -> m (f [ByteString])
sdiff = wrap1 "sdiff" Orig.sdiff
sdiffstore :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> [ByteString] -> m (f Integer)
sdiffstore = wrap2 "sdiffstore" Orig.sdiffstore
select :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => Integer -> m (f Status)
select = wrap1 "select" Orig.select
sendRequest :: ((RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack), RedisResult a) => [ByteString] -> m (f a)
sendRequest = wrap1 "sendRequest" Orig.sendRequest
set :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> m (f Status)
set = wrap2 "set" Orig.set
setOpts :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> SetOpts -> m (f Status)
setOpts = wrap3 "setOpts" Orig.setOpts
setbit :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Integer -> ByteString -> m (f Integer)
setbit = wrap3 "setbit" Orig.setbit
setex :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Integer -> ByteString -> m (f Status)
setex = wrap3 "setex" Orig.setex
setnx :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> m (f Bool)
setnx = wrap2 "setnx" Orig.setnx
setrange :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Integer -> ByteString -> m (f Integer)
setrange = wrap3 "setrange" Orig.setrange
sinter :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => [ByteString] -> m (f [ByteString])
sinter = wrap1 "sinter" Orig.sinter
sinterstore :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> [ByteString] -> m (f Integer)
sinterstore = wrap2 "sinterstore" Orig.sinterstore
sismember :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> m (f Bool)
sismember = wrap2 "sismember" Orig.sismember
slaveof :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> m (f Status)
slaveof = wrap2 "slaveof" Orig.slaveof
slowlogGet :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => Integer -> m (f [Slowlog])
slowlogGet = wrap1 "slowlogGet" Orig.slowlogGet
slowlogLen :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => m (f Integer)
slowlogLen = wrap0 "slowlogLen" Orig.slowlogLen
slowlogReset :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => m (f Status)
slowlogReset = wrap0 "slowlogReset" Orig.slowlogReset
smembers :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f [ByteString])
smembers = wrap1 "smembers" Orig.smembers
smove :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> ByteString -> m (f Bool)
smove = wrap3 "smove" Orig.smove
sort :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> SortOpts -> m (f [ByteString])
sort = wrap2 "sort" Orig.sort
sortStore :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> SortOpts -> m (f Integer)
sortStore = wrap3 "sortStore" Orig.sortStore
spop :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f (Maybe ByteString))
spop = wrap1 "spop" Orig.spop
spopN :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Integer -> m (f [ByteString])
spopN = wrap2 "spopN" Orig.spopN
srandmember :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f (Maybe ByteString))
srandmember = wrap1 "srandmember" Orig.srandmember
srandmemberN :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Integer -> m (f [ByteString])
srandmemberN = wrap2 "srandmemberN" Orig.srandmemberN
srem :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> [ByteString] -> m (f Integer)
srem = wrap2 "srem" Orig.srem
sscan :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Cursor -> m (f (Cursor, [ByteString]))
sscan = wrap2 "sscan" Orig.sscan
sscanOpts :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Cursor -> ScanOpts -> m (f (Cursor, [ByteString]))
sscanOpts = wrap3 "sscanOpts" Orig.sscanOpts
strlen :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f Integer)
strlen = wrap1 "strlen" Orig.strlen
sunion :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => [ByteString] -> m (f [ByteString])
sunion = wrap1 "sunion" Orig.sunion
sunionstore :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> [ByteString] -> m (f Integer)
sunionstore = wrap2 "sunionstore" Orig.sunionstore
time :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => m (f (Integer, Integer))
time = wrap0 "time" Orig.time
ttl :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f Integer)
ttl = wrap1 "ttl" Orig.ttl
wait :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => Integer -> Integer -> m (f Integer)
wait = wrap2 "wait" Orig.wait
xack :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> [ByteString] -> m (f Integer)
xack = wrap3 "xack" Orig.xack
xadd :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> [(ByteString, ByteString)] -> m (f ByteString)
xadd = wrap3 "xadd" Orig.xadd
xaddOpts :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> [(ByteString, ByteString)] -> TrimOpts -> m (f ByteString)
xaddOpts = wrap4 "xaddOpts" Orig.xaddOpts
xclaim :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> ByteString -> Integer -> XClaimOpts -> [ByteString] -> m (f [StreamsRecord])
xclaim = wrap6 "xclaim" Orig.xclaim
xclaimJustIds :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> ByteString -> Integer -> XClaimOpts -> [ByteString] -> m (f [ByteString])
xclaimJustIds = wrap6 "xclaimJustIds" Orig.xclaimJustIds
xdel :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> [ByteString] -> m (f Integer)
xdel = wrap2 "xdel" Orig.xdel
xgroupCreate :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> ByteString -> m (f Status)
xgroupCreate = wrap3 "xgroupCreate" Orig.xgroupCreate
xgroupDelConsumer :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> ByteString -> m (f Integer)
xgroupDelConsumer = wrap3 "xgroupDelConsumer" Orig.xgroupDelConsumer
xgroupDestroy :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> m (f Bool)
xgroupDestroy = wrap2 "xgroupDestroy" Orig.xgroupDestroy
xgroupSetId :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> ByteString -> m (f Status)
xgroupSetId = wrap3 "xgroupSetId" Orig.xgroupSetId
xinfoConsumers :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> m (f [XInfoConsumersResponse])
xinfoConsumers = wrap2 "xinfoConsumers" Orig.xinfoConsumers
xinfoGroups :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f [XInfoGroupsResponse])
xinfoGroups = wrap1 "xinfoGroups" Orig.xinfoGroups
xinfoStream :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f XInfoStreamResponse)
xinfoStream = wrap1 "xinfoStream" Orig.xinfoStream
xlen :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f Integer)
xlen = wrap1 "xlen" Orig.xlen
xpendingDetail :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> ByteString -> ByteString -> Integer -> Maybe ByteString -> m (f [XPendingDetailRecord])
xpendingDetail = wrap6 "xpendingDetail" Orig.xpendingDetail
xpendingSummary :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> Maybe ByteString -> m (f XPendingSummaryResponse)
xpendingSummary = wrap3 "xpendingSummary" Orig.xpendingSummary
xrange :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> ByteString -> Maybe Integer -> m (f [StreamsRecord])
xrange = wrap4 "xrange" Orig.xrange
xread :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => [(ByteString, ByteString)] -> m (f (Maybe [XReadResponse]))
xread = wrap1 "xread" Orig.xread
xreadGroup :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> [(ByteString, ByteString)] -> m (f (Maybe [XReadResponse]))
xreadGroup = wrap3 "xreadGroup" Orig.xreadGroup
xreadGroupOpts :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> [(ByteString, ByteString)] -> XReadOpts -> m (f (Maybe [XReadResponse]))
xreadGroupOpts = wrap4 "xreadGroupOpts" Orig.xreadGroupOpts
xreadOpts :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => [(ByteString, ByteString)] -> XReadOpts -> m (f (Maybe [XReadResponse]))
xreadOpts = wrap2 "xreadOpts" Orig.xreadOpts
xrevRange :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> ByteString -> Maybe Integer -> m (f [StreamsRecord])
xrevRange = wrap4 "xrevRange" Orig.xrevRange
xtrim :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> TrimOpts -> m (f Integer)
xtrim = wrap2 "xtrim" Orig.xtrim
zadd :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> [(Double, ByteString)] -> m (f Integer)
zadd = wrap2 "zadd" Orig.zadd
zaddOpts :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> [(Double, ByteString)] -> ZaddOpts -> m (f Integer)
zaddOpts = wrap3 "zaddOpts" Orig.zaddOpts
zcard :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> m (f Integer)
zcard = wrap1 "zcard" Orig.zcard
zcount :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Double -> Double -> m (f Integer)
zcount = wrap3 "zcount" Orig.zcount
zincrby :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Integer -> ByteString -> m (f Double)
zincrby = wrap3 "zincrby" Orig.zincrby
zinterstore :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> [ByteString] -> Aggregate -> m (f Integer)
zinterstore = wrap3 "zinterstore" Orig.zinterstore
zinterstoreWeights :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> [(ByteString, Double)] -> Aggregate -> m (f Integer)
zinterstoreWeights = wrap3 "zinterstoreWeights" Orig.zinterstoreWeights
zlexcount :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> ByteString -> m (f Integer)
zlexcount = wrap3 "zlexcount" Orig.zlexcount
zrange :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Integer -> Integer -> m (f [ByteString])
zrange = wrap3 "zrange" Orig.zrange
zrangeWithscores :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Integer -> Integer -> m (f [(ByteString, Double)])
zrangeWithscores = wrap3 "zrangeWithscores" Orig.zrangeWithscores
zrangebylex :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> RangeLex ByteString -> RangeLex ByteString -> m (f [ByteString])
zrangebylex = wrap3 "zrangebylex" Orig.zrangebylex
zrangebylexLimit :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> RangeLex ByteString -> RangeLex ByteString -> Integer -> Integer -> m (f [ByteString])
zrangebylexLimit = wrap5 "zrangebylexLimit" Orig.zrangebylexLimit
zrangebyscore :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Double -> Double -> m (f [ByteString])
zrangebyscore = wrap3 "zrangebyscore" Orig.zrangebyscore
zrangebyscoreLimit :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Double -> Double -> Integer -> Integer -> m (f [ByteString])
zrangebyscoreLimit = wrap5 "zrangebyscoreLimit" Orig.zrangebyscoreLimit
zrangebyscoreWithscores :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Double -> Double -> m (f [(ByteString, Double)])
zrangebyscoreWithscores = wrap3 "zrangebyscoreWithscores" Orig.zrangebyscoreWithscores
zrangebyscoreWithscoresLimit :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Double -> Double -> Integer -> Integer -> m (f [(ByteString, Double)])
zrangebyscoreWithscoresLimit = wrap5 "zrangebyscoreWithscoresLimit" Orig.zrangebyscoreWithscoresLimit
zrank :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> m (f (Maybe Integer))
zrank = wrap2 "zrank" Orig.zrank
zrem :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> [ByteString] -> m (f Integer)
zrem = wrap2 "zrem" Orig.zrem
zremrangebylex :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> ByteString -> m (f Integer)
zremrangebylex = wrap3 "zremrangebylex" Orig.zremrangebylex
zremrangebyrank :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Integer -> Integer -> m (f Integer)
zremrangebyrank = wrap3 "zremrangebyrank" Orig.zremrangebyrank
zremrangebyscore :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Double -> Double -> m (f Integer)
zremrangebyscore = wrap3 "zremrangebyscore" Orig.zremrangebyscore
zrevrange :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Integer -> Integer -> m (f [ByteString])
zrevrange = wrap3 "zrevrange" Orig.zrevrange
zrevrangeWithscores :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Integer -> Integer -> m (f [(ByteString, Double)])
zrevrangeWithscores = wrap3 "zrevrangeWithscores" Orig.zrevrangeWithscores
zrevrangebyscore :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Double -> Double -> m (f [ByteString])
zrevrangebyscore = wrap3 "zrevrangebyscore" Orig.zrevrangebyscore
zrevrangebyscoreLimit :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Double -> Double -> Integer -> Integer -> m (f [ByteString])
zrevrangebyscoreLimit = wrap5 "zrevrangebyscoreLimit" Orig.zrevrangebyscoreLimit
zrevrangebyscoreWithscores :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Double -> Double -> m (f [(ByteString, Double)])
zrevrangebyscoreWithscores = wrap3 "zrevrangebyscoreWithscores" Orig.zrevrangebyscoreWithscores
zrevrangebyscoreWithscoresLimit :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Double -> Double -> Integer -> Integer -> m (f [(ByteString, Double)])
zrevrangebyscoreWithscoresLimit = wrap5 "zrevrangebyscoreWithscoresLimit" Orig.zrevrangebyscoreWithscoresLimit
zrevrank :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> m (f (Maybe Integer))
zrevrank = wrap2 "zrevrank" Orig.zrevrank
zscan :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Cursor -> m (f (Cursor, [(ByteString, Double)]))
zscan = wrap2 "zscan" Orig.zscan
zscanOpts :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> Cursor -> ScanOpts -> m (f (Cursor, [(ByteString, Double)]))
zscanOpts = wrap3 "zscanOpts" Orig.zscanOpts
zscore :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> ByteString -> m (f (Maybe Double))
zscore = wrap2 "zscore" Orig.zscore
zunionstore :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> [ByteString] -> Aggregate -> m (f Integer)
zunionstore = wrap3 "zunionstore" Orig.zunionstore
zunionstoreWeights :: (RedisCtx m f, Otel.MonadTracer m, MonadUnliftIO m, HasCallStack) => ByteString -> [(ByteString, Double)] -> Aggregate -> m (f Integer)
zunionstoreWeights = wrap3 "zunionstoreWeights" Orig.zunionstoreWeights
