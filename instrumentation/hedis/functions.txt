-- functions whose type is form of `RedisCtx m f => ... -> m (f _)` in `Database.Redis`
append :: RedisCtx m f => ByteString -> ByteString -> m (f Integer)
auth :: RedisCtx m f => ByteString -> m (f Status)
bgrewriteaof :: RedisCtx m f => m (f Status)
bgsave :: RedisCtx m f => m (f Status)
bitcount :: RedisCtx m f => ByteString -> m (f Integer)
bitcountRange :: RedisCtx m f => ByteString -> Integer -> Integer -> m (f Integer)
bitopAnd :: RedisCtx m f => ByteString -> [ByteString] -> m (f Integer)
bitopNot :: RedisCtx m f => ByteString -> ByteString -> m (f Integer)
bitopOr :: RedisCtx m f => ByteString -> [ByteString] -> m (f Integer)
bitopXor :: RedisCtx m f => ByteString -> [ByteString] -> m (f Integer)
bitpos :: RedisCtx m f => ByteString -> Integer -> Integer -> Integer -> m (f Integer)
blpop :: RedisCtx m f => [ByteString] -> Integer -> m (f (Maybe (ByteString, ByteString)))
brpop :: RedisCtx m f => [ByteString] -> Integer -> m (f (Maybe (ByteString, ByteString)))
brpoplpush :: RedisCtx m f => ByteString -> ByteString -> Integer -> m (f (Maybe ByteString))
clientGetname :: RedisCtx m f => m (f Status)
clientList :: RedisCtx m f => m (f [ByteString])
clientPause :: RedisCtx m f => Integer -> m (f Status)
clientReply :: RedisCtx m f => ReplyMode -> m (f Bool)
clientSetname :: RedisCtx m f => ByteString -> m (f ByteString)
clusterGetKeysInSlot :: RedisCtx m f => Integer -> Integer -> m (f [ByteString])
clusterNodes :: RedisCtx m f => m (f ClusterNodesResponse)
clusterSetSlotImporting :: RedisCtx m f => Integer -> ByteString -> m (f Status)
clusterSetSlotMigrating :: RedisCtx m f => Integer -> ByteString -> m (f Status)
clusterSetSlotNode :: RedisCtx m f => Integer -> ByteString -> m (f Status)
clusterSetSlotStable :: RedisCtx m f => Integer -> m (f Status)
clusterSlots :: RedisCtx m f => m (f ClusterSlotsResponse)
command :: RedisCtx m f => m (f [CommandInfo])
commandCount :: RedisCtx m f => m (f Integer)
commandInfo :: RedisCtx m f => [ByteString] -> m (f [ByteString])
configGet :: RedisCtx m f => ByteString -> m (f [(ByteString, ByteString)])
configResetstat :: RedisCtx m f => m (f Status)
configRewrite :: RedisCtx m f => m (f Status)
configSet :: RedisCtx m f => ByteString -> ByteString -> m (f Status)
dbsize :: RedisCtx m f => m (f Integer)
debugObject :: RedisCtx m f => ByteString -> m (f ByteString)
decr :: RedisCtx m f => ByteString -> m (f Integer)
decrby :: RedisCtx m f => ByteString -> Integer -> m (f Integer)
del :: RedisCtx m f => [ByteString] -> m (f Integer)
dump :: RedisCtx m f => ByteString -> m (f ByteString)
echo :: RedisCtx m f => ByteString -> m (f ByteString)
eval :: (RedisCtx m f, RedisResult a) => ByteString -> [ByteString] -> [ByteString] -> m (f a)
evalsha :: (RedisCtx m f, RedisResult a) => ByteString -> [ByteString] -> [ByteString] -> m (f a)
exists :: RedisCtx m f => ByteString -> m (f Bool)
expire :: RedisCtx m f => ByteString -> Integer -> m (f Bool)
expireat :: RedisCtx m f => ByteString -> Integer -> m (f Bool)
flushall :: RedisCtx m f => m (f Status)
flushdb :: RedisCtx m f => m (f Status)
get :: RedisCtx m f => ByteString -> m (f (Maybe ByteString))
getType :: RedisCtx m f => ByteString -> m (f RedisType)
getbit :: RedisCtx m f => ByteString -> Integer -> m (f Integer)
getrange :: RedisCtx m f => ByteString -> Integer -> Integer -> m (f ByteString)
getset :: RedisCtx m f => ByteString -> ByteString -> m (f (Maybe ByteString))
hdel :: RedisCtx m f => ByteString -> [ByteString] -> m (f Integer)
hexists :: RedisCtx m f => ByteString -> ByteString -> m (f Bool)
hget :: RedisCtx m f => ByteString -> ByteString -> m (f (Maybe ByteString))
hgetall :: RedisCtx m f => ByteString -> m (f [(ByteString, ByteString)])
hincrby :: RedisCtx m f => ByteString -> ByteString -> Integer -> m (f Integer)
hincrbyfloat :: RedisCtx m f => ByteString -> ByteString -> Double -> m (f Double)
hkeys :: RedisCtx m f => ByteString -> m (f [ByteString])
hlen :: RedisCtx m f => ByteString -> m (f Integer)
hmget :: RedisCtx m f => ByteString -> [ByteString] -> m (f [Maybe ByteString])
hmset :: RedisCtx m f => ByteString -> [(ByteString, ByteString)] -> m (f Status)
hscan :: RedisCtx m f => ByteString -> Cursor -> m (f (Cursor, [(ByteString, ByteString)]))
hscanOpts :: RedisCtx m f => ByteString -> Cursor -> ScanOpts -> m (f (Cursor, [(ByteString, ByteString)]))
hset :: RedisCtx m f => ByteString -> ByteString -> ByteString -> m (f Integer)
hsetnx :: RedisCtx m f => ByteString -> ByteString -> ByteString -> m (f Bool)
hstrlen :: RedisCtx m f => ByteString -> ByteString -> m (f Integer)
hvals :: RedisCtx m f => ByteString -> m (f [ByteString])
incr :: RedisCtx m f => ByteString -> m (f Integer)
incrby :: RedisCtx m f => ByteString -> Integer -> m (f Integer)
incrbyfloat :: RedisCtx m f => ByteString -> Double -> m (f Double)
info :: RedisCtx m f => m (f ByteString)
infoSection :: RedisCtx m f => ByteString -> m (f ByteString)
keys :: RedisCtx m f => ByteString -> m (f [ByteString])
lastsave :: RedisCtx m f => m (f Integer)
lindex :: RedisCtx m f => ByteString -> Integer -> m (f (Maybe ByteString))
linsertAfter :: RedisCtx m f => ByteString -> ByteString -> ByteString -> m (f Integer)
linsertBefore :: RedisCtx m f => ByteString -> ByteString -> ByteString -> m (f Integer)
llen :: RedisCtx m f => ByteString -> m (f Integer)
lpop :: RedisCtx m f => ByteString -> m (f (Maybe ByteString))
lpush :: RedisCtx m f => ByteString -> [ByteString] -> m (f Integer)
lpushx :: RedisCtx m f => ByteString -> ByteString -> m (f Integer)
lrange :: RedisCtx m f => ByteString -> Integer -> Integer -> m (f [ByteString])
lrem :: RedisCtx m f => ByteString -> Integer -> ByteString -> m (f Integer)
lset :: RedisCtx m f => ByteString -> Integer -> ByteString -> m (f Status)
ltrim :: RedisCtx m f => ByteString -> Integer -> Integer -> m (f Status)
mget :: RedisCtx m f => [ByteString] -> m (f [Maybe ByteString])
migrate :: RedisCtx m f => ByteString -> ByteString -> ByteString -> Integer -> Integer -> m (f Status)
migrateMultiple :: RedisCtx m f => ByteString -> ByteString -> Integer -> Integer -> MigrateOpts -> [ByteString] -> m (f Status)
move :: RedisCtx m f => ByteString -> Integer -> m (f Bool)
mset :: RedisCtx m f => [(ByteString, ByteString)] -> m (f Status)
msetnx :: RedisCtx m f => [(ByteString, ByteString)] -> m (f Bool)
objectEncoding :: RedisCtx m f => ByteString -> m (f ByteString)
objectIdletime :: RedisCtx m f => ByteString -> m (f Integer)
objectRefcount :: RedisCtx m f => ByteString -> m (f Integer)
persist :: RedisCtx m f => ByteString -> m (f Bool)
pexpire :: RedisCtx m f => ByteString -> Integer -> m (f Bool)
pexpireat :: RedisCtx m f => ByteString -> Integer -> m (f Bool)
pfadd :: RedisCtx m f => ByteString -> [ByteString] -> m (f Integer)
pfcount :: RedisCtx m f => [ByteString] -> m (f Integer)
pfmerge :: RedisCtx m f => ByteString -> [ByteString] -> m (f ByteString)
ping :: RedisCtx m f => m (f Status)
psetex :: RedisCtx m f => ByteString -> Integer -> ByteString -> m (f Status)
pttl :: RedisCtx m f => ByteString -> m (f Integer)
publish :: RedisCtx m f => ByteString -> ByteString -> m (f Integer)
quit :: RedisCtx m f => m (f Status)
randomkey :: RedisCtx m f => m (f (Maybe ByteString))
rename :: RedisCtx m f => ByteString -> ByteString -> m (f Status)
renamenx :: RedisCtx m f => ByteString -> ByteString -> m (f Bool)
restore :: RedisCtx m f => ByteString -> Integer -> ByteString -> m (f Status)
restoreReplace :: RedisCtx m f => ByteString -> Integer -> ByteString -> m (f Status)
rpop :: RedisCtx m f => ByteString -> m (f (Maybe ByteString))
rpoplpush :: RedisCtx m f => ByteString -> ByteString -> m (f (Maybe ByteString))
rpush :: RedisCtx m f => ByteString -> [ByteString] -> m (f Integer)
rpushx :: RedisCtx m f => ByteString -> ByteString -> m (f Integer)
sadd :: RedisCtx m f => ByteString -> [ByteString] -> m (f Integer)
save :: RedisCtx m f => m (f Status)
scan :: RedisCtx m f => Cursor -> m (f (Cursor, [ByteString]))
scanOpts :: RedisCtx m f => Cursor -> ScanOpts -> m (f (Cursor, [ByteString]))
scard :: RedisCtx m f => ByteString -> m (f Integer)
scriptDebug :: RedisCtx m f => DebugMode -> m (f Bool)
scriptExists :: RedisCtx m f => [ByteString] -> m (f [Bool])
scriptFlush :: RedisCtx m f => m (f Status)
scriptKill :: RedisCtx m f => m (f Status)
scriptLoad :: RedisCtx m f => ByteString -> m (f ByteString)
sdiff :: RedisCtx m f => [ByteString] -> m (f [ByteString])
sdiffstore :: RedisCtx m f => ByteString -> [ByteString] -> m (f Integer)
select :: RedisCtx m f => Integer -> m (f Status)
sendRequest :: (RedisCtx m f, RedisResult a) => [ByteString] -> m (f a)
set :: RedisCtx m f => ByteString -> ByteString -> m (f Status)
setOpts :: RedisCtx m f => ByteString -> ByteString -> SetOpts -> m (f Status)
setbit :: RedisCtx m f => ByteString -> Integer -> ByteString -> m (f Integer)
setex :: RedisCtx m f => ByteString -> Integer -> ByteString -> m (f Status)
setnx :: RedisCtx m f => ByteString -> ByteString -> m (f Bool)
setrange :: RedisCtx m f => ByteString -> Integer -> ByteString -> m (f Integer)
sinter :: RedisCtx m f => [ByteString] -> m (f [ByteString])
sinterstore :: RedisCtx m f => ByteString -> [ByteString] -> m (f Integer)
sismember :: RedisCtx m f => ByteString -> ByteString -> m (f Bool)
slaveof :: RedisCtx m f => ByteString -> ByteString -> m (f Status)
slowlogGet :: RedisCtx m f => Integer -> m (f [Slowlog])
slowlogLen :: RedisCtx m f => m (f Integer)
slowlogReset :: RedisCtx m f => m (f Status)
smembers :: RedisCtx m f => ByteString -> m (f [ByteString])
smove :: RedisCtx m f => ByteString -> ByteString -> ByteString -> m (f Bool)
sort :: RedisCtx m f => ByteString -> SortOpts -> m (f [ByteString])
sortStore :: RedisCtx m f => ByteString -> ByteString -> SortOpts -> m (f Integer)
spop :: RedisCtx m f => ByteString -> m (f (Maybe ByteString))
spopN :: RedisCtx m f => ByteString -> Integer -> m (f [ByteString])
srandmember :: RedisCtx m f => ByteString -> m (f (Maybe ByteString))
srandmemberN :: RedisCtx m f => ByteString -> Integer -> m (f [ByteString])
srem :: RedisCtx m f => ByteString -> [ByteString] -> m (f Integer)
sscan :: RedisCtx m f => ByteString -> Cursor -> m (f (Cursor, [ByteString]))
sscanOpts :: RedisCtx m f => ByteString -> Cursor -> ScanOpts -> m (f (Cursor, [ByteString]))
strlen :: RedisCtx m f => ByteString -> m (f Integer)
sunion :: RedisCtx m f => [ByteString] -> m (f [ByteString])
sunionstore :: RedisCtx m f => ByteString -> [ByteString] -> m (f Integer)
time :: RedisCtx m f => m (f (Integer, Integer))
ttl :: RedisCtx m f => ByteString -> m (f Integer)
wait :: RedisCtx m f => Integer -> Integer -> m (f Integer)
xack :: RedisCtx m f => ByteString -> ByteString -> [ByteString] -> m (f Integer)
xadd :: RedisCtx m f => ByteString -> ByteString -> [(ByteString, ByteString)] -> m (f ByteString)
xaddOpts :: RedisCtx m f => ByteString -> ByteString -> [(ByteString, ByteString)] -> TrimOpts -> m (f ByteString)
xclaim :: RedisCtx m f => ByteString -> ByteString -> ByteString -> Integer -> XClaimOpts -> [ByteString] -> m (f [StreamsRecord])
xclaimJustIds :: RedisCtx m f => ByteString -> ByteString -> ByteString -> Integer -> XClaimOpts -> [ByteString] -> m (f [ByteString])
xdel :: RedisCtx m f => ByteString -> [ByteString] -> m (f Integer)
xgroupCreate :: RedisCtx m f => ByteString -> ByteString -> ByteString -> m (f Status)
xgroupDelConsumer :: RedisCtx m f => ByteString -> ByteString -> ByteString -> m (f Integer)
xgroupDestroy :: RedisCtx m f => ByteString -> ByteString -> m (f Bool)
xgroupSetId :: RedisCtx m f => ByteString -> ByteString -> ByteString -> m (f Status)
xinfoConsumers :: RedisCtx m f => ByteString -> ByteString -> m (f [XInfoConsumersResponse])
xinfoGroups :: RedisCtx m f => ByteString -> m (f [XInfoGroupsResponse])
xinfoStream :: RedisCtx m f => ByteString -> m (f XInfoStreamResponse)
xlen :: RedisCtx m f => ByteString -> m (f Integer)
xpendingDetail :: RedisCtx m f => ByteString -> ByteString -> ByteString -> ByteString -> Integer -> Maybe ByteString -> m (f [XPendingDetailRecord])
xpendingSummary :: RedisCtx m f => ByteString -> ByteString -> Maybe ByteString -> m (f XPendingSummaryResponse)
xrange :: RedisCtx m f => ByteString -> ByteString -> ByteString -> Maybe Integer -> m (f [StreamsRecord])
xread :: RedisCtx m f => [(ByteString, ByteString)] -> m (f (Maybe [XReadResponse]))
xreadGroup :: RedisCtx m f => ByteString -> ByteString -> [(ByteString, ByteString)] -> m (f (Maybe [XReadResponse]))
xreadGroupOpts :: RedisCtx m f => ByteString -> ByteString -> [(ByteString, ByteString)] -> XReadOpts -> m (f (Maybe [XReadResponse]))
xreadOpts :: RedisCtx m f => [(ByteString, ByteString)] -> XReadOpts -> m (f (Maybe [XReadResponse]))
xrevRange :: RedisCtx m f => ByteString -> ByteString -> ByteString -> Maybe Integer -> m (f [StreamsRecord])
xtrim :: RedisCtx m f => ByteString -> TrimOpts -> m (f Integer)
zadd :: RedisCtx m f => ByteString -> [(Double, ByteString)] -> m (f Integer)
zaddOpts :: RedisCtx m f => ByteString -> [(Double, ByteString)] -> ZaddOpts -> m (f Integer)
zcard :: RedisCtx m f => ByteString -> m (f Integer)
zcount :: RedisCtx m f => ByteString -> Double -> Double -> m (f Integer)
zincrby :: RedisCtx m f => ByteString -> Integer -> ByteString -> m (f Double)
zinterstore :: RedisCtx m f => ByteString -> [ByteString] -> Aggregate -> m (f Integer)
zinterstoreWeights :: RedisCtx m f => ByteString -> [(ByteString, Double)] -> Aggregate -> m (f Integer)
zlexcount :: RedisCtx m f => ByteString -> ByteString -> ByteString -> m (f Integer)
zrange :: RedisCtx m f => ByteString -> Integer -> Integer -> m (f [ByteString])
zrangeWithscores :: RedisCtx m f => ByteString -> Integer -> Integer -> m (f [(ByteString, Double)])
zrangebylex :: RedisCtx m f => ByteString -> RangeLex ByteString -> RangeLex ByteString -> m (f [ByteString])
zrangebylexLimit :: RedisCtx m f => ByteString -> RangeLex ByteString -> RangeLex ByteString -> Integer -> Integer -> m (f [ByteString])
zrangebyscore :: RedisCtx m f => ByteString -> Double -> Double -> m (f [ByteString])
zrangebyscoreLimit :: RedisCtx m f => ByteString -> Double -> Double -> Integer -> Integer -> m (f [ByteString])
zrangebyscoreWithscores :: RedisCtx m f => ByteString -> Double -> Double -> m (f [(ByteString, Double)])
zrangebyscoreWithscoresLimit :: RedisCtx m f => ByteString -> Double -> Double -> Integer -> Integer -> m (f [(ByteString, Double)])
zrank :: RedisCtx m f => ByteString -> ByteString -> m (f (Maybe Integer))
zrem :: RedisCtx m f => ByteString -> [ByteString] -> m (f Integer)
zremrangebylex :: RedisCtx m f => ByteString -> ByteString -> ByteString -> m (f Integer)
zremrangebyrank :: RedisCtx m f => ByteString -> Integer -> Integer -> m (f Integer)
zremrangebyscore :: RedisCtx m f => ByteString -> Double -> Double -> m (f Integer)
zrevrange :: RedisCtx m f => ByteString -> Integer -> Integer -> m (f [ByteString])
zrevrangeWithscores :: RedisCtx m f => ByteString -> Integer -> Integer -> m (f [(ByteString, Double)])
zrevrangebyscore :: RedisCtx m f => ByteString -> Double -> Double -> m (f [ByteString])
zrevrangebyscoreLimit :: RedisCtx m f => ByteString -> Double -> Double -> Integer -> Integer -> m (f [ByteString])
zrevrangebyscoreWithscores :: RedisCtx m f => ByteString -> Double -> Double -> m (f [(ByteString, Double)])
zrevrangebyscoreWithscoresLimit :: RedisCtx m f => ByteString -> Double -> Double -> Integer -> Integer -> m (f [(ByteString, Double)])
zrevrank :: RedisCtx m f => ByteString -> ByteString -> m (f (Maybe Integer))
zscan :: RedisCtx m f => ByteString -> Cursor -> m (f (Cursor, [(ByteString, Double)]))
zscanOpts :: RedisCtx m f => ByteString -> Cursor -> ScanOpts -> m (f (Cursor, [(ByteString, Double)]))
zscore :: RedisCtx m f => ByteString -> ByteString -> m (f (Maybe Double))
zunionstore :: RedisCtx m f => ByteString -> [ByteString] -> Aggregate -> m (f Integer)
zunionstoreWeights :: RedisCtx m f => ByteString -> [(ByteString, Double)] -> Aggregate -> m (f Integer)
